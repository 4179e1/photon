操作系统基础 - 线程级并发

# 前言

在前面的系列文章中，我们了解了操作系统如何通过CPU和内存的虚拟化完成了多进程的并发。在某些场景下，进程级的并发存在一些问题：

- 进程间通讯相对比较复杂，需要操作系统提供专门的接口来支持。
- 创建一个进程的开销比较大，因此像是传统的基于fork的web server很难承载高并发请求的场景。

# 线程

操作系统提供了线程来解决这些问题，在同一个进程地址空间内实现了多个逻辑控制流（即线程），它们可以像进程一样调度，具体实现上：

- 每个线程对应一个栈，因此一个使用多线程的进程中有多个栈，而不是一个。
- 这些线程共享代码段、全局数据段、以及堆，线程间通讯直接通过全局数据段或堆来完成，避免了复杂的IPC机制

> CPU在切换线程的时候，依然需要上下文切换，但是这里不需要切换页表

![](./img/threads.png)

*图1 - 单线程和多线程地址空间*

多线程并发需要解决的问题有两个：

- 多个线程同时存取共享数据的时候，如何保证其原子性，操作系统提供了锁(lock)来解决这个问题
- 如何同步多个线程的执行顺序，最典型的场景是生产者消费者问题，解决方案是锁和条件变量(condition variable)


# 锁：保证数据存取的原子性

## 问题描述

下面这个程序通过两个线程累加一个计数器，正常情况下它的输出应该是输入值的两倍：

```C
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

static volatile int counter = 0;

void *mythread(void *arg)
{
    int i;
    int n = (int)arg;
    for (i = 0; i < n; i++)
    {
        counter = counter 1;
    }
    return NULL;
}

int main(int argc, char *argv[])
{
    pthread_t p1, p2;
    int n = atoi(argv[1]);

    pthread_create(&p1, NULL, mythread, (void *)n);
    pthread_create(&p2, NULL, mythread, (void *)n);

    pthread_join(p1, NULL);
    pthread_join(p2, NULL);

    printf("Counter: %d\n", counter);
    return 0;
}

```

我们可以看到在循环次数少的时候，程序能输出正确的结果，但是循环次数高了之后，结果是无法预期的

```bash
# ./concurrent 1000
Counter: 2000
# ./concurrent 10000000
Counter: 16086576
# ./concurrent 10000000
Counter: 14018391
```

这里的原因在于，CPU执行`counter = counter + 1`的时候不是原子的，它实际是三条语句

```asm
mov 0x8049a1c, %eax     ; 假设0x8049a1c是counter的地址
add $0x1, %eax
mov %eax, 0x8049a1c
```

两个线程A和B同时执行这条语句的时候，可能出现类似这样的情况：

- A和B都执行了第一条语句，把同样的值存到%eax中
- A执行第二和第三条语句，把结果写回counter的内存地址
- B执行第二和第三条语句，把结果写回counter的内存地址，把A的结果覆盖了

# 条件变量：同步线程

# 信号量