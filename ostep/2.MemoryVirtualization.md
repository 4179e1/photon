操作系统基础-内存虚拟化

# 前言

在CPU虚拟化中我们采用的是分时复用的机制——在不同的时刻运行不同的进程；而在内存虚拟化中需要用到另一种复用技术——空间复用，即把物理内存的不同部分划分给不同的进程。但是如果每个进程在运行时需要先知道自己的物理内存地址，比如说某个指针的物理地址是什么，这对编译器和开发者来说都是非常不友好的， 从易用性的角度出发，我们希望所有进程的地址空间都是类似的。因此操作系统引入了一层转换，隐式地把进程看到的地址（逻辑地址）转换成实际的物理内存地址（物理地址）。

# 进程地址空间

在研究如何进行逻辑地址到线性地址的转换前，先来看看一个进程的地址空间(Space Address)需要包含什么内容，我们先以一个非常小的地址空间为起点，它总共只有16K，也就是说这个进程只能使用16K的内存。

> 只需要14位的无符号数就能完整地表示这16K的地址，类似地32位地址可以表示4GiB的地址空间，而目前的64位系统通常只使用48位，地址空间大小为256TiB。

![](./img/address_space.png)


大体来说，这个地址空间可以分成3个段（Segment)：

1. 代码段（图中0-1KB的部分），程序的二进制指令保存在这里
2. 用来存放动态数据的堆（Heap，图中1-2KB的部分）， malloc的内存就从这里申请，当现有堆大小不够的时候往高地址扩展
3. 用来追踪函数调用的栈（Stack，途中16-15KB的部分），里面保存了每个函数调用中的局部变量，参数等信息，每层函数调用都会导致堆往低地址扩展

这个地址空间忽略了很多东西，比如代码段和堆之前还有全局变量，BSS段等。但是我们可以看到，这个地址空间是相当稀疏的，堆和栈之间有一大片地址没有利用起来。

假设我们有很多个进程，怎么把每个进程的逻辑地址空间映射到物理地址呢？

# Base and Bounds

最简单的机制叫做Base and Bounds，因为每个进程的地址空间大小都是固定，只需要把物理内存按照同样的大小分割，按需分配给不同的进程即可。比如下图中，物理地址的32-48K被分配给了一个进程。

![](./img/base_and_bounds.png)


具体实现上，CPU上有两个寄存器用来记录这些信息：
- Base 寄存器用来记录当前进程在物理内存的起始位置(32K)
- Bounds 寄存器用来记录该进程地址空间的边界（16K）

> 毫无疑问，这两个寄存器的值在上下切换的时候需要保存到PCB中。

操作系统在做逻辑地址到物理地址的转换时非常容易，只要给逻辑地址加上Base寄存器的值即可。然而这种模式有很严重的问题:

1. 这个地址空间太小，虽然我们可以放大这个地址空间（比如说640K……），但无论如何不能超过物理内存的大小
2. 更严重的问题是，堆和栈之间有一大片分配了却没有使用的地址，地址空间越大，这里的浪费越明显。

# 段式寻址

为了解决Base and Bounds的问题，人们引入了段式寻址(Segmentation)，其核心思路是，为地址空间的每一个段（Segment）分配一组Base和Bounds寄存器。进程的代码段，堆和栈可以分配到物理内存的不同位置，而不需要占据连续的空间：

![](./img/segmentation.png)

这里有一个问题，当进程引用一个逻辑地址的时候，怎么知道它是那个段呢？VAX/VMS里面采用了地址的前两位来区分

| 地址前两位 | 段   |
| ---------- | ---- |
| 00         | 代码 |
| 01         | 堆   |
| 10         | 栈   |
| 11         | 内核 |

段式寻址带来的另一个好处是，如果运行同一个程序的多个副本时，因为代码段是只读的，这些进程的代码段可以映射到同一个物理内存区域。

但是段式寻址没有解决根本问题，假如一个进程申请了一个巨大的堆，比如说1GB，然后释放了这1GB里面大部分的空间，只留下开头和结尾各1KB的空间，这同样导致了一个巨大的浪费。我们需要更精细的内存分配手段。

# Pagetable

解决这个问题的思路是每次只分配一小片内存，按需分配，这一小片内存的大小通常为4KB，称之为一页（page）。按照同样的大小切割逻辑地址空间和物理地址空间，比如前面16K的地址空间可以划分成4个逻辑页（Virtual Page），编号为0-3；我们再假设物理内存大小为32K，因此可以划分成8个物理页（page Frame），编号为0-7。

这时需要一个数据结构来记录逻辑地址到物理地址的映射关系，最简单的数据结构就是数组，这个数组称为页表(pagetable)，数组的每一个元素称为页表项目(Page Table Entry，或PTE)，其内容就是这个逻辑页对应的物理页编号。 对于16K的逻辑地址空间，每个进程只需要一个大小为4的页表就足够记录其逻辑地址和虚拟地址的对应关系，例如：

![](img/pagetable.png)


![](img/pfn.png)

上图可以看到，进程的逻辑页0、1、3分别映射到物理页3、7、2，而逻辑页2没有使用，因此处于没有分配的状态。读者们会注意到，PTE至少应该包含一个标记位，用来表示这个页是否已经分配，是的，而且PTE上还不止一个标记位，比如X86的PTE如下：

![](img/pte.png)